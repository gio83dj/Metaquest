<!DOCTYPE html>
<html lang="it">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ombra 3D Volumetrica del Tesseratto</title>
    <style>
        body { margin: 0; overflow: hidden; }
        canvas { width: 100%; height: 100%; }
    </style>
</head>
<body>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r134/three.min.js"></script>
    <script>
        // Configurazione della scena
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x111111);
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 3, 6);
        camera.lookAt(0, 0, 0);

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        document.body.appendChild(renderer.domElement);

        // Vertici 4D del tesseratto
        const tesseractVertices4D = [];
        for (let x = -1; x <= 1; x += 2) {
            for (let y = -1; y <= 1; y += 2) {
                for (let z = -1; z <= 1; z += 2) {
                    for (let w = -1; w <= 1; w += 2) {
                        tesseractVertices4D.push([x, y, z, w]);
                    }
                }
            }
        }

        // Celle cubiche del tesseratto (8 cubi)
        const cubeCells = [
            [0, 1, 2, 3, 4, 5, 6, 7],    // w = -1
            [8, 9, 10, 11, 12, 13, 14, 15], // w = +1
            [0, 8, 2, 10, 4, 12, 6, 14], // connessione lungo x
            [1, 9, 3, 11, 5, 13, 7, 15],
            [0, 1, 8, 9, 4, 5, 12, 13],  // connessione lungo y
            [2, 3, 10, 11, 6, 7, 14, 15],
            [0, 2, 8, 10, 1, 3, 9, 11],  // connessione lungo z
            [4, 6, 12, 14, 5, 7, 13, 15]
        ];

        // Funzione di proiezione 4D -> 3D per il tesseratto
        function project4Dto3D(vertex4D, distance = 4) {
            const [x, y, z, w] = vertex4D;
            const factor = distance / (distance - w);
            return new THREE.Vector3(x * factor, y * factor, z * factor);
        }

        // Funzione di proiezione 4D -> 3D per l'ombra
        function projectShadow3D(vertex4D, distance = 4) {
            const [x, y, z, w] = vertex4D;
            const factor = distance / (distance - w);
            return new THREE.Vector3(x * factor, y * factor - 2, z * factor); // Spostata in y
        }

        // Crea una mesh cubica per l'ombra
        function createCubeMesh() {
            const geometry = new THREE.BoxGeometry(2, 2, 2);
            const material = new THREE.MeshPhongMaterial({ color: 0x666666, side: THREE.DoubleSide });
            const cube = new THREE.Mesh(geometry, material);
            cube.castShadow = true;
            cube.receiveShadow = true;
            return cube;
        }

        // Crea le mesh delle celle cubiche per l'ombra
        const shadowCubes = cubeCells.map(() => createCubeMesh());
        shadowCubes.forEach(cube => scene.add(cube));

        // Linee del tesseratto
        const edges = [];
        for (let i = 0; i < 16; i++) {
            for (let j = i + 1; j < 16; j++) {
                const diff = tesseractVertices4D[i].map((v, k) => Math.abs(v - tesseractVertices4D[j][k]));
                if (diff.filter(d => d === 2).length === 1 && diff.filter(d => d !== 0).length === 1) {
                    edges.push([i, j]);
                }
            }
        }
        const tesseractLines = edges.map(([start, end]) => {
            const lineGeo = new THREE.BufferGeometry();
            const lineMaterial = new THREE.LineBasicMaterial({ color: 0xffffff, linewidth: 2 });
            const line = new THREE.Line(lineGeo, lineMaterial);
            scene.add(line);
            return line;
        });

        // Illuminazione
        const directionalLight = new THREE.DirectionalLight(0xffffff, 3);
        directionalLight.position.set(5, 5, 5);
        directionalLight.castShadow = true;
        scene.add(directionalLight);

        const ambientLight = new THREE.AmbientLight(0x606060, 1);
        scene.add(ambientLight);

        // Rotazione 4D
        let angleXW = 0;
        let angleYZ = 0;
        const rotateSpeed = 0.005;
        function rotate4D() {
            angleXW += rotateSpeed;
            angleYZ += rotateSpeed * 1.5;
            const cosXW = Math.cos(angleXW);
            const sinXW = Math.sin(angleXW);
            const cosYZ = Math.cos(angleYZ);
            const sinYZ = Math.sin(angleYZ);

            const rotatedVertices4D = tesseractVertices4D.map(([x, y, z, w]) => {
                const newX = x * cosXW - w * sinXW;
                const newW = x * sinXW + w * cosXW;
                const newY = y * cosYZ - z * sinYZ;
                const newZ = y * sinYZ + z * cosYZ;
                return [newX, newY, newZ, newW];
            });

            // Aggiorna le linee del tesseratto
            const projectedVertices = rotatedVertices4D.map(v => project4Dto3D(v));
            tesseractLines.forEach((line, i) => {
                const [start, end] = edges[i];
                line.geometry.setFromPoints([projectedVertices[start], projectedVertices[end]]);
            });

            // Aggiorna le mesh delle celle cubiche per l'ombra
            const shadowVertices = rotatedVertices4D.map(v => projectShadow3D(v));
            shadowCubes.forEach((cube, i) => {
                const cell = cubeCells[i];
                const positions = cell.map(index => shadowVertices[index]);
                const center = positions.reduce((acc, p) => acc.add(p), new THREE.Vector3()).divideScalar(8);
                cube.position.copy(center);
            });
        }

        // Animazione
        function animate() {
            renderer.setAnimationLoop(() => {
                rotate4D();
                renderer.render(scene, camera);
            });
        }
        animate();

        // Adattamento alla finestra
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>