<!DOCTYPE html>
<html lang="it">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Visione 4D - Tesseratto con Ombra Volumetrica in VR</title>
    <style>
        body { margin: 0; overflow: hidden; }
        canvas { width: 100%; height: 100%; }
        #vrButton {
            position: absolute;
            bottom: 20px;
            right: 20px;
            padding: 12px 20px;
            background: #000;
            color: #fff;
            border: 1px solid #fff;
            cursor: pointer;
            font-family: sans-serif;
            font-size: 16px;
        }
    </style>
</head>
<body>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r134/three.min.js"></script>
    <script>
        // Scena, camera, renderer
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x111111);
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 1.6, 3); // Altezza tipica per VR (circa altezza occhi)

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.xr.enabled = true; // Abilita WebXR per VR
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        document.body.appendChild(renderer.domElement);

        // Gruppo per il movimento VR
        const vrRig = new THREE.Group();
        vrRig.add(camera);
        scene.add(vrRig);

        // Orologio per il deltaTime
        const clock = new THREE.Clock();

        // Pulsante VR
        const vrButton = document.createElement('button');
        vrButton.id = 'vrButton';
        vrButton.textContent = 'ENTER VR';
        vrButton.onclick = () => {
            renderer.xr.getSession() || renderer.xr.setSession(navigator.xr.requestSession('immersive-vr'));
        };
        if (navigator.xr) {
            navigator.xr.isSessionSupported('immersive-vr').then(supported => {
                document.body.appendChild(vrButton);
                if (!supported) {
                    vrButton.textContent = 'VR NON SUPPORTATO';
                    vrButton.disabled = true;
                }
            });
        } else {
            vrButton.textContent = 'WEBXR NON DISPONIBILE';
            vrButton.disabled = true;
            document.body.appendChild(vrButton);
        }

        // Pavimento per l’ombra
        const floorGeometry = new THREE.PlaneGeometry(20, 20);
        const floorMaterial = new THREE.MeshPhongMaterial({ color: 0x222222, side: THREE.DoubleSide });
        const floor = new THREE.Mesh(floorGeometry, floorMaterial);
        floor.rotation.x = -Math.PI / 2;
        floor.position.y = -4.0;
        floor.receiveShadow = true;
        scene.add(floor);

        // Vertici 4D del tesseratto
        const tesseractVertices4D = [];
        for (let x = -1; x <= 1; x += 2) {
            for (let y = -1; y <= 1; y += 2) {
                for (let z = -1; z <= 1; z += 2) {
                    for (let w = -1; w <= 1; w += 2) {
                        tesseractVertices4D.push([x, y, z, w]);
                    }
                }
            }
        }

        // Celle cubiche del tesseratto (8 cubi)
        const cubeCells = [
            [0, 1, 2, 3, 4, 5, 6, 7],    // w = -1
            [8, 9, 10, 11, 12, 13, 14, 15], // w = +1
            [0, 8, 2, 10, 4, 12, 6, 14], // x
            [1, 9, 3, 11, 5, 13, 7, 15],
            [0, 1, 8, 9, 4, 5, 12, 13],  // y
            [2, 3, 10, 11, 6, 7, 14, 15],
            [0, 2, 8, 10, 1, 3, 9, 11],  // z
            [4, 6, 12, 14, 5, 7, 13, 15]
        ];

        // Proiezione 4D -> 3D per il tesseratto
        function project4Dto3D(vertex4D) {
            const [x, y, z, w] = vertex4D;
            const distance = 4;
            const factor = distance / (distance - w);
            return new THREE.Vector3(x * factor, y * factor, z * factor);
        }

        // Proiezione 4D -> 3D per l’ombra
        function projectShadow3D(vertex4D) {
            const [x, y, z, w] = vertex4D;
            const distance = 4;
            const factor = distance / (distance - w);
            return new THREE.Vector3(x * factor, y * factor - 4, z * factor); // Ombra a y = -4
        }

        // Crea una mesh cubica per l’ombra
        function createCubeMesh() {
            const geometry = new THREE.BoxGeometry(2, 2, 2);
            const material = new THREE.MeshPhongMaterial({ color: 0x666666, side: THREE.DoubleSide });
            const cube = new THREE.Mesh(geometry, material);
            cube.castShadow = true;
            cube.receiveShadow = true;
            return cube;
        }

        // Mesh delle celle cubiche per l’ombra
        const shadowCubes = cubeCells.map(() => createCubeMesh());
        shadowCubes.forEach(cube => scene.add(cube));

        // Linee del tesseratto
        const edges = [];
        for (let i = 0; i < 16; i++) {
            for (let j = i + 1; j < 16; j++) {
                const diff = tesseractVertices4D[i].map((v, k) => Math.abs(v - tesseractVertices4D[j][k]));
                if (diff.filter(d => d === 2).length === 1 && diff.filter(d => d !== 0).length === 1) {
                    edges.push([i, j]);
                }
            }
        }
        const tesseractLines = edges.map(([start, end]) => {
            const lineGeo = new THREE.BufferGeometry();
            const lineMaterial = new THREE.LineBasicMaterial({ color: 0xffffff, linewidth: 2 });
            const line = new THREE.Line(lineGeo, lineMaterial);
            scene.add(line);
            return line;
        });

        // Gruppo del tesseratto
        const tesseractGroup = new THREE.Group();
        tesseractLines.forEach(line => tesseractGroup.add(line));
        scene.add(tesseractGroup);

        // Illuminazione
        const directionalLight = new THREE.DirectionalLight(0xffffff, 3);
        directionalLight.position.set(5, 5, 5);
        directionalLight.castShadow = true;
        directionalLight.shadow.mapSize.width = 1024;
        directionalLight.shadow.mapSize.height = 1024;
        directionalLight.shadow.camera.near = 0.5;
        directionalLight.shadow.camera.far = 50;
        scene.add(directionalLight);

        const ambientLight = new THREE.AmbientLight(0x606060, 1);
        scene.add(ambientLight);

        // Rotazione 4D
        let angleXW = 0;
        let angleYZ = 0;
        const rotateSpeed = 0.005;
        function rotate4D() {
            angleXW += rotateSpeed;
            angleYZ += rotateSpeed * 1.5;
            const cosXW = Math.cos(angleXW);
            const sinXW = Math.sin(angleXW);
            const cosYZ = Math.cos(angleYZ);
            const sinYZ = Math.sin(angleYZ);

            const rotatedVertices4D = tesseractVertices4D.map(([x, y, z, w]) => {
                const newX = x * cosXW - w * sinXW;
                const newW = x * sinXW + w * cosXW;
                const newY = y * cosYZ - z * sinYZ;
                const newZ = y * sinYZ + z * cosYZ;
                return [newX, newY, newZ, newW];
            });

            // Aggiorna le linee del tesseratto
            const projectedVertices = rotatedVertices4D.map(project4Dto3D);
            tesseractLines.forEach((line, i) => {
                const [start, end] = edges[i];
                line.geometry.setFromPoints([projectedVertices[start], projectedVertices[end]]);
            });

            // Aggiorna le mesh delle celle cubiche per l’ombra
            const shadowVertices = rotatedVertices4D.map(projectShadow3D);
            shadowCubes.forEach((cube, i) => {
                const cell = cubeCells[i];
                const positions = cell.map(index => shadowVertices[index]);
                const center = positions.reduce((acc, p) => acc.add(p), new THREE.Vector3()).divideScalar(8);
                cube.position.copy(center);
            });
        }

        // Movimento con il joystick del Meta Quest 3
        function updateMovement(deltaTime) {
            if (renderer.xr.isPresenting) {
                const session = renderer.xr.getSession();
                if (session) {
                    const inputSources = session.inputSources;
                    for (const source of inputSources) {
                        if (source.handedness === 'left' && source.gamepad) {
                            const gamepad = source.gamepad;
                            const axes = gamepad.axes; // Joystick sinistro
                            if (axes.length >= 2) {
                                const horizontal = axes[0]; // Sinistra/Destra
                                const vertical = axes[1];   // Avanti/Indietro
                                const forward = new THREE.Vector3();
                                camera.getWorldDirection(forward);
                                forward.y = 0;
                                forward.normalize();
                                const up = new THREE.Vector3(0, 1, 0);
                                const right = new THREE.Vector3().crossVectors(forward, up).normalize();
                                const speed = 2.0; // Velocità di movimento
                                const movement = forward.clone().multiplyScalar(-vertical * speed * deltaTime);
                                const strafe = right.clone().multiplyScalar(horizontal * speed * deltaTime);
                                vrRig.position.add(movement).add(strafe);
                            }
                        }
                    }
                }
            }
        }

        // Animazione
        function animate() {
            renderer.setAnimationLoop(() => {
                const deltaTime = clock.getDelta();
                rotate4D();
                tesseractGroup.rotation.y += 0.005;
                updateMovement(deltaTime);
                renderer.render(scene, camera);
            });
        }
        animate();

        // Adatta alla finestra
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>